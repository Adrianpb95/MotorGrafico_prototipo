/*
ADRIAN PONCE BALSEIRO
ESNE G4.3 DDVJ
adrianpb95@gmail.com
3 / 07 / 2018
*/

#ifndef TASK_HEADER
#define TASK_HEADER

////////////////////////////////////////////////////////////
// Headers
////////////////////////////////////////////////////////////
#include <list>
#include "Component.hpp"

////////////////////////////////////////////////////////////
// NameSpaces
////////////////////////////////////////////////////////////
using std::shared_ptr;
using std::list;
namespace example
{
	class Scene;
	class Task
	{

		////////////////////////////////////////////////////////////
		// Declaracion de variables			
		////////////////////////////////////////////////////////////

	protected:
		
		list<shared_ptr<Component>> components;			///<Conjunto de componentes
		Scene * scene;									///<Escena a la pertenece la tarea
		int priority;									///<Prioridad de ejecucion de la tarea 
		bool finished;									///<Bool: final de la tarea ?
			

		////////////////////////////////////////////////////////////
		// Declaracion de funciones			
		////////////////////////////////////////////////////////////

	public:

		////////////////////////////////////////////////////////////
		/// \brief	Constructor de Task:	Inicializa las variables que va a usar
		///	@param	scene			Escena a la que pertenece
		///	@param	priority		Prioridad de la tarea
		///	@param	finished		Tarea finalizada (?)
		////////////////////////////////////////////////////////////
		Task(Scene * scene, int priority, bool finished);

		////////////////////////////////////////////////////////////
		/// \brief	Destructor de Task
		////////////////////////////////////////////////////////////
		~Task()
		{
			components.clear();
		}
		
		////////////////////////////////////////////////////////////
		/// \brief	SETTER de un componente en la tarea
		///	@param	component		Componente a añadir
		////////////////////////////////////////////////////////////
		void add_component(shared_ptr<Component> component)
		{
			components.push_back(component);
		}	

		////////////////////////////////////////////////////////////
		/// \brief	GETTER de finished
		////////////////////////////////////////////////////////////
		bool is_finished()
		{
			return finished;
		}

		////////////////////////////////////////////////////////////
		/// \brief	Inicializacion de la tarea
		////////////////////////////////////////////////////////////
		virtual void initialize() = 0;
		////////////////////////////////////////////////////////////
		/// \brief	Ejecucion de la tarea
		////////////////////////////////////////////////////////////
		virtual void run() = 0;	
		////////////////////////////////////////////////////////////
		/// \brief	Finalizacion de la tarea
		////////////////////////////////////////////////////////////
		virtual void finalize() = 0;


		////////////////////////////////////////////////////////////
		// OPERACIONES
		////////////////////////////////////////////////////////////
		bool operator > (const Task & other) const
		{
			return this->priority > other.priority;
		}

		bool operator < (const Task & other) const
		{
			return !(*this > other);
		}

		bool operator >= (const Task & other) const
		{
			return this->priority >= other.priority;
		}

		bool operator <= (const Task & other) const
		{
			return !(*this >= other);
		}

		bool operator == (const Task & other) const
		{
			return this->priority == other.priority;
		}

		bool operator != (const Task & other) const
		{
			return !(*this == other);
		}
	};
}

#endif
