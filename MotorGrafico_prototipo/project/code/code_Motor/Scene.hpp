/*
ADRIAN PONCE BALSEIRO
ESNE G4.3 DDVJ
adrianpb95@gmail.com
3 / 07 / 2018
*/

#ifndef SCENE_HEADER
#define SCENE_HEADER

////////////////////////////////////////////////////////////
// Headers
////////////////////////////////////////////////////////////
#include "Entity.hpp"
#include "Module.hpp"
#include "View.hpp"
#include "Kernel.hpp"
#include "Dispatcher.hpp"

////////////////////////////////////////////////////////////
// NameSpaces
////////////////////////////////////////////////////////////
namespace example
{
	class Scene
	{

		////////////////////////////////////////////////////////////
		// Declaracion de variables			
		////////////////////////////////////////////////////////////

	private:

		Kernel * kernel;									///<Kernel a ejecutar
		View * view;										///<Ventana a renderizar
		Dispatcher * dispatcher;							///<Dispatcher de mensajeria

		map<string, shared_ptr<Entity>> entities;			///<Conjunto de entidades de la escena
		map<string, shared_ptr<Module>> modules;			///<Conjunto de modulos de la escena


		////////////////////////////////////////////////////////////
		// Declaracion de funciones			
		////////////////////////////////////////////////////////////

	public:

		////////////////////////////////////////////////////////////
		/// \brief	Constructor de Scene:	Carga la escena desde xml e inicializa el kernel de tareas
		///	@param	path		Ruta del archivo xml para cargar la escena
		////////////////////////////////////////////////////////////
		Scene(const string & path);

		////////////////////////////////////////////////////////////
		/// \brief	Destructor de Scene
		////////////////////////////////////////////////////////////
		~Scene();

		////////////////////////////////////////////////////////////
		/// \brief	Activa el kernel
		////////////////////////////////////////////////////////////
		void execute()
		{
			kernel->execute();
		}

		////////////////////////////////////////////////////////////
		/// \brief	GETTER de una entidad de la escena
		///	@param	name		Nombre identificador de la entidad
		////////////////////////////////////////////////////////////
		shared_ptr<Entity> get_entity(const string & name)
		{
			return entities[name];
		}

		////////////////////////////////////////////////////////////
		/// \brief	GETTER del kernel
		////////////////////////////////////////////////////////////
		Kernel * get_kernel() const
		{
			return kernel;
		}
		
		////////////////////////////////////////////////////////////
		/// \brief	GETTER de la ventana
		////////////////////////////////////////////////////////////
		View * get_view() const
		{
			return view;
		}

		////////////////////////////////////////////////////////////
		/// \brief	GETTER del dispatcher 
		////////////////////////////////////////////////////////////
		Dispatcher * get_dispatcher() const
		{
			return dispatcher;
		}


	private:

		////////////////////////////////////////////////////////////
		/// \brief	Comienza el proceso de leer la informacion del xml
		///	@param	path		Ruta del xml
		////////////////////////////////////////////////////////////
		void load_scene(const string & path);

		////////////////////////////////////////////////////////////
		/// \brief	Lee el xml y crea la ventana y la escena con todos sus elementos
		///	@param	scene_node		Nodo de escena en el xml
		////////////////////////////////////////////////////////////
		View * parse_scene(xml_node<> * scene_node);

		////////////////////////////////////////////////////////////
		/// \brief	Lee el xml y crea las entidades con sus atributos
		///	@param	entity_node		Nodo de entidad en el xml
		////////////////////////////////////////////////////////////
		void parse_entity(xml_node<> * entity_node);

		////////////////////////////////////////////////////////////
		/// \brief	Lee el xml y crea los componentes con sus atributos
		///	@param	component_node		Nodo de componente en el xml
		///	@param	entity				Entidad a la que pertenece el componente
		////////////////////////////////////////////////////////////
		void parse_components(xml_node<> * component_node, Entity & entity);
	};
}

#endif
